#version 330 core


const int MAX_POINT_LIGHTS = 4;

struct DirectionalLight
{
	vec3 ambientColor;
	float ambientIntensity;

	vec3 directionalColor;
	float directionalIntensity;
	vec3 direction;
};


struct PointLight
{
	vec3 position;
	vec3 color;
	float constant;
	float linear;
	float exponential;
};


struct Material
{
	float specularIntensity;
	float shininess;
};

in vec4 vCol;
in vec2 vUV;
in vec3 vNormal;
in vec3 FragPos; // worldspace pos

// Ouput data
out vec4 color;

// reason why this is automatically identified as the bound texture is because there's only ONE atm.
// If there were more than one texture we'd have to bind the uniform
uniform sampler2D mainTexSampler; 


uniform DirectionalLight dirLight;
uniform PointLight pointLights[MAX_POINT_LIGHTS];
uniform int pointLightCount;

uniform Material material;
uniform vec3 cameraWorldPos;


vec4 CalcDirectionalLight()
{
	vec4 ambientLight = vec4( dirLight.ambientColor, 1.0f) * dirLight.ambientIntensity;
	vec4 diffuseColor = vec4( dirLight.directionalColor, 1.0f) * dirLight.directionalIntensity;

	float diffuseFactor =  max( dot( normalize(vNormal), dirLight.direction) , 0.0f);
	diffuseColor *= diffuseFactor;

	vec4 specularColor = vec4(0);
	if( diffuseFactor > 0)
	{
		vec3 viewDir = normalize(cameraWorldPos - FragPos);
		vec3 lightRefl = normalize(reflect( dirLight.direction, normalize(vNormal)));
		float specularFactor = dot(viewDir, lightRefl);
		
		if( specularFactor > 0) // needed?
		{
			specularFactor = pow(specularFactor, material.shininess);
			specularColor = vec4(dirLight.directionalColor * material.specularIntensity * specularFactor, 1);
		}
	}

	vec4 finalDirLight = (ambientLight + diffuseColor + specularColor);

	return finalDirLight;
}


vec4 CalcPointLights()
{
	vec4 accumulatedPointLightsColor = vec4(0,0,0,0);
	for(int i = 0; i < pointLightCount; i++)
	{
		vec4 diffuseColor = vec4( pointLights[i].color, 1.0f);
		
		vec3 lightDir = (FragPos - pointLights[i].position);
		float lightDistance = length(lightDir);
		lightDir = normalize(lightDir);

		float diffuseFactor =  max( dot( normalize(vNormal), lightDir) , 0.0f);
		diffuseColor *= diffuseFactor;
		
		vec4 specularColor = vec4(0);
		if( diffuseFactor > 0)
		{
			//Specular

			vec3 viewDir = normalize(cameraWorldPos - FragPos);
			vec3 lightRefl = normalize(reflect( lightDir, normalize(vNormal)));
			float specularFactor = dot(viewDir, lightRefl);
			
			if( specularFactor > 0) // needed?
			{
				specularFactor = pow(specularFactor, material.shininess);
				specularColor = vec4(pointLights[i].color * material.specularIntensity * specularFactor, 1);
			}
		}
		
		float attenuation = pointLights[i].exponential * lightDistance * lightDistance + 
							pointLights[i].linear * lightDistance +
							pointLights[i].constant;


		accumulatedPointLightsColor += ( (diffuseColor + specularColor) / attenuation);
	}

	return accumulatedPointLightsColor;
}

void main()
{
	vec4 ambientLightColor = CalcDirectionalLight();
	vec4 pointLightsColor = CalcPointLights();

	color = texture(mainTexSampler, vUV) *  (ambientLightColor + pointLightsColor);
}